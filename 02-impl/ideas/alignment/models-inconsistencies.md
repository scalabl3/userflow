# Model Layer Design and Standards

## Overview
This document defines our model layer standards and patterns, established through careful consideration and implementation across our core models.

## Standardized Patterns

### 1. Migration Structure
```typescript
/**
 * Clear, comprehensive documentation including:
 * - Core Fields and their constraints
 * - Relationships and their behaviors
 * - Indices and their purposes
 * - State management details
 */
export class CreateEntity implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        // Get relationship configurations first
        const relationship = getManyToOneRelation(
            'entityId',
            'entity',
            true,  // required
            'RESTRICT'  // deletion behavior
        );

        await queryRunner.createTable(
            new Table({
                name: 'entity_name',
                columns: [
                    getIdColumn(queryRunner),
                    // Core fields with explicit constraints
                    // Relationship columns using helpers
                    // State management fields
                    ...getTimestampColumns(queryRunner)
                ],
                indices: [
                    {
                        name: 'IDX_ENTITY_FIELD',  // Standardized naming
                        columnNames: ['field'],
                        isUnique: true  // When needed
                    }
                ],
                foreignKeys: [
                    relationship.constraint
                ]
            })
        );
    }
}
```

### 2. Helper Functions
```typescript
// UUID and Primary Keys
getIdColumn(queryRunner)  // Standard UUID PK
getManyToOneRelation(    // M:1 relationships
    columnName,
    referencedTable,
    required,
    onDelete
)
getOneToOneRelation(     // 1:1 relationships
    columnName,
    referencedTable,
    required,
    unique,
    onDelete
)

// Enums and JSON
getEnumColumn(name, values, nullable)  // Type-safe enums
getJsonColumn(          // Database-specific JSON
    queryRunner,
    name,
    nullable,
    defaultValue
)

// Common Fields
getTimestampColumns(queryRunner)  // created/modified
```

### 3. Naming Conventions
- Tables: Singular, snake_case (e.g., `login_provider`)
- Columns: camelCase
- Indices: `IDX_TABLE_FIELD`
- Foreign Keys: Generated by relationship helpers
- Enums: Named types (e.g., `credential_type`)

### 4. Field Standards
```typescript
// Varchar Fields
{
    name: 'field',
    type: 'varchar',
    length: '255',  // Explicit length
    isNullable: false
}

// Boolean Flags
{
    name: 'isEnabled',
    type: 'boolean',
    isNullable: false,
    default: true  // Explicit default
}

// Timestamps
{
    name: 'createdAt',
    type: 'datetime',
    default: () => 'CURRENT_TIMESTAMP'
}
```

## Implementation Examples

### 1. Authentication System
- **LoginProvider**: Root entity with code/name pattern
- **LoginCredential**: Complex entity with conditional fields
- **BaseUser**: Parent entity with core user fields
- **User**: Extended entity with organization relationship

### 2. Organization System
- **Organization**: Entity with admin relationship
- **User**: Entity with organization membership

### 3. Billing System
- **BillingProvider**: Entity with type-based behavior

## Best Practices

### 1. Relationship Management
- Use appropriate helper for relationship type
- Consider deletion behavior carefully
- Document relationship constraints
- Add indices for foreign keys

### 2. Documentation
- Document all fields and constraints
- Explain relationship behaviors
- Note future considerations
- Include usage examples

### 3. Migration Organization
- CREATE migrations for table structure
- Separate ADD-FK migrations for relationships
- Clear dependency order
- Reversible changes

### 4. Data Safety
- Explicit nullability
- Proper length constraints
- Appropriate defaults
- Type safety with enums

## Verification Checklist
- [ ] Uses appropriate helper functions
- [ ] Has comprehensive documentation
- [ ] Follows naming conventions
- [ ] Includes proper indices
- [ ] Handles relationships correctly
- [ ] Specifies field constraints
- [ ] Provides proper defaults
- [ ] Considers database compatibility

## Next Steps
1. Apply standards to new models
2. Review model-related services
3. Establish testing patterns
4. Document validation strategies

## Model Layer Standards and Patterns

## Overview
This document tracks our model layer standards, patterns, and remaining inconsistencies that need to be addressed.

## Standardized Patterns (âœ…)

### 1. UUID and Primary Key Standards
```typescript
// Primary Keys
@PrimaryGeneratedColumn('uuid')  // TypeORM handles database-specific UUID generation
id!: string;

// Foreign Keys (Required)
@Column({ type: 'uuid' })
@IsUUID()
entityId!: string;

// Foreign Keys (Optional)
@Column({ type: 'uuid', nullable: true })
@IsUUID()
@IsOptional()
entityId?: string;
```

### 2. Enum Standards
```typescript
@Column({
    type: 'varchar',  // Always use varchar for database compatibility
    enum: EnumType    // Keep enum for TypeScript & validation
})
@IsEnum(EnumType)    // Always include validation
enumField!: EnumType;
```

### 3. Timestamp Standards
```typescript
// Creation/Update Timestamps
@CreateDateColumn({ 
    type: 'datetime',
    default: () => 'CURRENT_TIMESTAMP'
})
createdAt!: Date;

@UpdateDateColumn({ 
    type: 'datetime',
    default: () => 'CURRENT_TIMESTAMP'
})
modifiedAt!: Date;

// Other Date Fields
@Column({ 
    type: 'datetime',
    nullable: true
})
@IsDate()
@IsOptional()
someDate?: Date;
```

### 4. JSON Column Standards
```typescript
// Using the helper function
@Column(getJsonColumn(queryRunner, 'data', true))
@IsObject()
@ValidateNested()
@Type(() => DataType)
@IsOptional()
data?: DataType;

// Best practices:
// 1. Always use getJsonColumn helper
// 2. Define explicit types (no Record<string, any>)
// 3. Use class-validator decorators
// 4. Use class-transformer for type conversion
// 5. Consider default values
// 6. Keep structures simple and flat
// 7. Avoid complex queries in SQLite
```

## Patterns Requiring Standardization (ðŸ”„)

### 1. Relationship Declarations
Current inconsistencies:
- Inconsistent nullable specifications between @Column and @ManyToOne
- Mixed use of relationship cardinality
- Missing @JoinColumn decorators

Proposed standard:
```typescript
// Required relationship
@Column({ type: 'uuid' })
@IsUUID()
entityId!: string;

@ManyToOne(() => Entity)
@JoinColumn({ name: 'entityId' })
entity!: Entity;
```

### 2. Index Decorators
Current inconsistencies:
- Mixed use of @Index and column options
- Inconsistent documentation of index purposes
- Varying approaches to unique constraints

### 3. Documentation Standards
Current inconsistencies:
- Varying levels of detail
- Inconsistent structure
- Missing relationship documentation

### 4. Field Organization
Standard defined but not consistently implemented:
```typescript
@Entity()
export class EntityName {
    // 1. Primary Key
    // 2. Required Core Fields
    // 3. Optional Core Fields
    // 4. Relationship Fields
    // 5. Timestamps
}
```

### 5. Soft Deletion
Helper available but decisions needed:
- Which entities should use soft deletion?
- How to handle relationships with soft-deleted records?
- CASCADE behavior
- Unique constraint handling

## Authentication Models Standardization

### LoginCredential Model
- **Relationship Standards**
  - Many-to-One relationships with both LoginProvider and BaseUser
  - Both relationships are required and protected from deletion (RESTRICT)
  - Proper indexing on foreign keys and composite unique constraint
  - Uses standardized `getModelRelationConfig` helper for relationship configuration

- **Enum Handling**
  - `credentialType`: Uses proper enum column with named type
  - `provider`: Nullable enum for OAuth providers with named type
  - Both use TypeORM's enum support with explicit type names

- **JSON Data**
  - OAuth profile data structured using `OAuthProfile` class
  - Proper validation with `class-validator` decorators
  - Default values provided for JSON fields
  - Uses `simple-json` for SQLite compatibility

- **Conditional Fields**
  - Password-specific fields only validated when `credentialType === PASSWORD`